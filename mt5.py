# Creating a professional MT5 module file that follows SOLID, DDD, asyncio, and OOP principles.
# The file will be written to /mnt/data/mt5_module.py and then displayed so you can copy or download it.
# Note: This module depends on the `MetaTrader5` package. If it's not installed in your environment,
# the runtime demonstration will show an informative message and the module will remain ready for use.

"""
mt5_module.py
A professional MT5 integration module designed for use with an autonomous trading agent.
Principles: SOLID, Domain-Driven Design (DDD), asyncio, OOP.
Dependencies: MetaTrader5 (pip install MetaTrader5)
Author: Generated by assistant — adapt account credentials and environment before use.
"""

from __future__ import annotations
import asyncio
import concurrent.futures
import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal
from typing import List, Optional, Protocol, Tuple, Dict, Any
import math

# Try to import MetaTrader5 but handle the case where it's unavailable (for testing environments)
try:
    import MetaTrader5 as mt5  # type: ignore
except Exception as e:
    mt5 = None  # type: ignore

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

# ----------------------------- Domain Layer (DDD) -----------------------------

@dataclass(frozen=True)
class SymbolInfo:
    name: str
    point: float
    digits: int
    trade_tick_size: float
    trade_contract_size: float
    swap_long: float
    swap_short: float
    spread: float
    volume_step: float

@dataclass
class MarketCandle:
    time: datetime  # UTC
    open: float
    high: float
    low: float
    close: float
    tick_volume: int
    spread: Optional[int] = None

@dataclass
class AccountState:
    login: int
    balance: float
    equity: float
    free_margin: float
    margin_level: Optional[float]

@dataclass
class OrderResult:
    success: bool
    ticket: Optional[int]
    comment: Optional[str]
    raw: Optional[Dict[str, Any]] = None

# --------------------------- Ports / Interfaces (SOLID) -------------------------

class IMarketDataRepository(Protocol):
    async def get_symbol_info(self, symbol: str) -> SymbolInfo:
        ...

    async def get_last_candles(self, symbol: str, timeframe: int, count: int) -> List[MarketCandle]:
        ...

    async def get_account_state(self) -> AccountState:
        ...

class ITradeExecutionService(Protocol):
    async def place_market_order(self,
                                 symbol: str,
                                 action: str,  # 'buy' or 'sell'
                                 lot: float,
                                 stop_loss: Optional[float],
                                 take_profit: Optional[float],
                                 comment: Optional[str]) -> OrderResult:
        ...

    async def close_position(self, ticket: int) -> OrderResult:
        ...

# -------------------------- Application / Infrastructure ------------------------

class MT5Connector:
    """
    Responsible for initializing and shutting down the MetaTrader5 native connection.
    Keeps connection logic centralized (Single Responsibility).
    """
    def __init__(self):
        self._connected = False
        self._lock = asyncio.Lock()
        # ThreadPoolExecutor for converting blocking MT5 calls to async-friendly calls
        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)

    async def __aenter__(self):
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc, tb):
        await self.disconnect()

    async def connect(self) -> None:
        async with self._lock:
            if self._connected:
                return
            if mt5 is None:
                logger.warning("MetaTrader5 package not available in this environment.")
                self._connected = False
                return
            loop = asyncio.get_running_loop()
            ok = await loop.run_in_executor(self._executor, mt5.initialize)
            if not ok:
                raise ConnectionError(f"MT5 initialize failed: {mt5.last_error() if hasattr(mt5, 'last_error') else 'unknown'}")
            self._connected = True
            logger.info("MT5 initialized successfully.")

    async def disconnect(self) -> None:
        async with self._lock:
            if not self._connected:
                return
            if mt5 is None:
                self._connected = False
                return
            loop = asyncio.get_running_loop()
            await loop.run_in_executor(self._executor, mt5.shutdown)
            self._connected = False
            logger.info("MT5 shutdown completed.")

    @property
    def connected(self) -> bool:
        return self._connected

    def executor(self):
        return self._executor

# -------------------------- Concrete Repository / Service -----------------------

class MT5MarketDataRepository(IMarketDataRepository):
    """
    Concrete implementation that fetches market data from MT5.
    Uses run_in_executor to keep library calls non-blocking for asyncio usage.
    """
    def __init__(self, connector: MT5Connector):
        self._connector = connector

    async def get_symbol_info(self, symbol: str) -> SymbolInfo:
        if mt5 is None:
            raise RuntimeError("MetaTrader5 package not installed or not available.")
        loop = asyncio.get_running_loop()
        raw = await loop.run_in_executor(self._connector.executor(), lambda: mt5.symbol_info_tick(symbol))
        # If symbol_info_tick returns None, try symbol_info
        if raw is None:
            raw = await loop.run_in_executor(self._connector.executor(), lambda: mt5.symbol_info(symbol))
            if raw is None:
                raise ValueError(f"Symbol {symbol} not found in MT5 terminal.")
        # wrap fields - some fields differ depending on object type
        #point = getattr(raw, "point", getattr(raw, "tick_size", 0.0))
        point = getattr(raw, "point", 0.0)
        if not point or point == 0.0:
            point = 10 ** (-getattr(raw, "digits", 5))
        digits = getattr(raw, "digits", getattr(raw, "precision", 5))
        contract_size = getattr(raw, "trade_contract_size", getattr(raw, "contract_size", 100000))
        spread = getattr(raw, "spread", 0)
        swap_long = getattr(raw, "swap_long", 0.0)
        swap_short = getattr(raw, "swap_short", 0.0)
        volume_step = getattr(raw, "volume_step", 0.01)
        if volume_step == 0.0:
            volume_step = 0.01
        trade_tick_size = point
        return SymbolInfo(
            name=symbol,
            point=float(point),
            digits=int(digits),
            trade_tick_size=float(trade_tick_size),
            trade_contract_size=float(contract_size),
            swap_long=float(swap_long),
            swap_short=float(swap_short),
            spread=float(spread),
            volume_step=float(volume_step)
        )

    async def get_last_candles(self, symbol: str, timeframe: int, count: int) -> List[MarketCandle]:
        if mt5 is None:
            raise RuntimeError("MetaTrader5 package not installed or not available.")
        loop = asyncio.get_running_loop()
        # mt5.copy_rates_from_pos(symbol, timeframe, start_pos, count)
        def _copy():
            return mt5.copy_rates_from_pos(symbol, timeframe, 0, count)
        raw = await loop.run_in_executor(self._connector.executor(), _copy)
        if raw is None:
            raise RuntimeError(f"Failed to fetch candles for {symbol} timeframe {timeframe}")
        candles: List[MarketCandle] = []
        for r in raw:
            t = datetime.fromtimestamp(int(r[0]), tz=timezone.utc)
            candles.append(MarketCandle(
                time=t,
                open=float(r[1]),
                high=float(r[2]),
                low=float(r[3]),
                close=float(r[4]),
                tick_volume=int(r[5]),
                spread=int(r[6]) if len(r) > 6 else None
            ))
        return candles

    async def get_account_state(self) -> AccountState:
        if mt5 is None:
            raise RuntimeError("MetaTrader5 package not installed or not available.")
        loop = asyncio.get_running_loop()
        raw = await loop.run_in_executor(self._connector.executor(), mt5.account_info)
        if raw is None:
            raise RuntimeError("Failed to fetch account information from MT5.")
        return AccountState(
            login=int(raw.login),
            balance=float(raw.balance),
            equity=float(raw.equity),
            free_margin=float(getattr(raw, "margin_free", getattr(raw, "free_margin", 0.0))),
            margin_level=float(getattr(raw, "margin_level", 0.0)) if getattr(raw, "margin_level", None) is not None else None
        )

class MT5TradeExecutionService(ITradeExecutionService):
    """
    Trade execution service that encapsulates order placing and closing logic.
    """
    def __init__(self, connector: MT5Connector, default_deviation: int = 20):
        self._connector = connector
        self._deviation = default_deviation  # max slippage in points

    async def _prepare_order_request(self, symbol: str, action: str, lot: float,
                                     stop_loss: Optional[float], take_profit: Optional[float],
                                     comment: Optional[str]) -> Dict[str, Any]:
        # Validate inputs
        if action not in ("buy", "sell"):
            raise ValueError("action must be 'buy' or 'sell'")

        if mt5 is None:
            raise RuntimeError("MetaTrader5 package not installed or not available.")

        loop = asyncio.get_running_loop()

        info = await loop.run_in_executor(self._connector.executor(), lambda: mt5.symbol_info_tick(symbol))
        price = None
        if info is None:
            # fallback to symbol_info
            si = await loop.run_in_executor(self._connector.executor(), lambda: mt5.symbol_info(symbol))
            if si is None:
                raise ValueError(f"Symbol not found: {symbol}")

            volume_min = getattr(si, "volume_min", 0.01)

            # Check if lot is too small
            if lot < volume_min:
                raise ValueError(f"Calculated lot {lot} is below minimum {volume_min} for {symbol}")

            price = si.ask if action == "buy" else si.bid
        else:
            price = info.ask if action == "buy" else info.bid

        order_type = mt5.ORDER_TYPE_BUY if action == "buy" else mt5.ORDER_TYPE_SELL

        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": float(lot),
            "type": order_type,
            "price": float(price),
            "sl": float(stop_loss) if stop_loss is not None else None,
            "tp": float(take_profit) if take_profit is not None else None,
            "deviation": int(self._deviation),
            "magic": 123456,
            "comment": comment or "auto-trade",
            "type_filling": mt5.ORDER_FILLING_FOK if hasattr(mt5, "ORDER_FILLING_FOK") else mt5.ORDER_FILLING_RETURN,
        }
        return request

    async def place_market_order(self,
                                 symbol: str,
                                 action: str,
                                 lot: float,
                                 stop_loss: Optional[float],
                                 take_profit: Optional[float],
                                 comment: Optional[str] = None) -> OrderResult:
        if mt5 is None:
            return OrderResult(success=False, ticket=None, comment="MetaTrader5 package not installed.", raw=None)
        loop = asyncio.get_running_loop()
        request = await self._prepare_order_request(symbol, action, lot, stop_loss, take_profit, comment)
        def _send():
            return mt5.order_send(request)
        result = await loop.run_in_executor(self._connector.executor(), _send)
        # result is typically a structure with retcode and order fields
        if result is None:
            return OrderResult(success=False, ticket=None, comment="MT5 returned None to order_send", raw=None)
        try:
            retcode = getattr(result, "retcode", getattr(result, "retcode", None))
            logger.info(f"Order send result: {result}")
            if retcode is not None and int(retcode) == 10009:  # REQUEST_RET_OK may vary — use safe check
                ticket = getattr(result, "order", None)
                return OrderResult(success=True, ticket=int(ticket) if ticket is not None else None, comment="Order placed", raw=result._asdict() if hasattr(result, "_asdict") else result.__dict__ if hasattr(result, "__dict__") else str(result))
            # If there is an error code, capture it
            return OrderResult(success=False, ticket=None, comment=f"Order failed: retcode={retcode}", raw=result._asdict() if hasattr(result, "_asdict") else result.__dict__ if hasattr(result, "__dict__") else str(result))
        except Exception as exc:
            logger.exception("Error interpreting order result")
            return OrderResult(success=False, ticket=None, comment=str(exc), raw=str(result))

    async def close_position(self, ticket: int) -> OrderResult:
        if mt5 is None:
            return OrderResult(success=False, ticket=None, comment="MetaTrader5 package not installed.", raw=None)
        loop = asyncio.get_running_loop()
        # Build close request based on position info
        def _get_pos():
            return mt5.positions_get(ticket=ticket)
        pos = await loop.run_in_executor(self._connector.executor(), _get_pos)
        if not pos:
            return OrderResult(success=False, ticket=None, comment=f"No position found with ticket {ticket}", raw=None)
        position = pos[0]
        symbol = position.symbol
        volume = position.volume
        # close type depends on position direction
        order_type = mt5.ORDER_TYPE_SELL if position.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
        # get current price
        tick = await loop.run_in_executor(self._connector.executor(), lambda: mt5.symbol_info_tick(symbol))
        price = tick.bid if order_type == mt5.ORDER_TYPE_SELL else tick.ask
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": float(volume),
            "type": order_type,
            "position": int(position.ticket),
            "price": float(price),
            "deviation": int(self._deviation),
            "magic": 123456,
            "comment": "close-position",
            "type_filling": mt5.ORDER_FILLING_FOK if hasattr(mt5, "ORDER_FILLING_FOK") else mt5.ORDER_FILLING_RETURN,
        }
        def _send():
            return mt5.order_send(request)
        result = await loop.run_in_executor(self._connector.executor(), _send)
        if result is None:
            return OrderResult(success=False, ticket=None, comment="MT5 returned None to order_send", raw=None)
        retcode = getattr(result, "retcode", None)
        if retcode is not None and int(retcode) == 10009:
            return OrderResult(success=True, ticket=int(getattr(result, "order", None)), comment="Position closed", raw=result._asdict() if hasattr(result, "_asdict") else result.__dict__ if hasattr(result, "__dict__") else str(result))
        return OrderResult(success=False, ticket=None, comment=f"Close failed: retcode={retcode}", raw=result)

# -------------------------- Utilities & Helpers --------------------------------

def calculate_lot_size(account_balance: float,
                       risk_percent: float,
                       stop_loss_pips: float,
                       pip_value_per_lot: float,
                       volume_step: float) -> float:
    """
    Deterministic lot size calculation.
    Lot Size = (Account Balance * risk_percent) / (stop_loss_pips * pip_value_per_lot)
    Returns lot size rounded to 2 decimal places (customize per broker if needed).
    """
    if stop_loss_pips <= 0 or pip_value_per_lot <= 0:
        raise ValueError("stop_loss_pips and pip_value_per_lot must be positive")
    if volume_step <= 0:
        raise ValueError("volume_step must be positive")

    risk_usd = Decimal(str(account_balance)) * Decimal(str(risk_percent))
    denom = Decimal(str(stop_loss_pips)) * Decimal(str(pip_value_per_lot))
    if denom == 0.0:
        return 0.0
    lot = float(risk_usd / denom)

    # Correct rounding based on volume_step
    # Example: lot=0.25, volume_step=0.1 -> 0.2
    # Example: lot=0.25, volume_step=1.0 -> 0.0
    lot_quantized = math.floor(lot / volume_step) * volume_step

    # Return rounded to a safe number of decimals
    return round(lot_quantized, 8)


# -------------------------- Example Agent Integration ---------------------------

async def example_decision_cycle(symbol: str, timeframe: int = mt5.TIMEFRAME_M15 if mt5 is not None else 15):
    """
    Example of how an external decision engine can use the repository + execution service.
    This function is illustrative — integrate with your decision logic based on the provided prompt.
    """
    connector = MT5Connector()
    await connector.connect()
    repo = MT5MarketDataRepository(connector)
    exec_svc = MT5TradeExecutionService(connector)

    try:
        account = await repo.get_account_state()
        logger.info(f"Account: {account}")
        info = await repo.get_symbol_info(symbol)
        logger.info(f"SymbolInfo: {info}")

        candles = await repo.get_last_candles(symbol, timeframe, 10)
        if not candles:
            logger.warning("No candles returned")
            return

        latest = candles[-1]
        # Simple example signal: price above previous candle high -> buy
        previous = candles[-2]
        if latest.close > previous.high and latest.close > candles[-3].high or True:
            # compute lot
            stop_loss_price = latest.close - (info.point * 50)  # naive 50-pip stop if point corresponds to pip
            stop_loss_pips = abs((latest.close - stop_loss_price) / info.point)
            pip_value = 10.0  # user must compute exact pip value using account currency and pair
            lot = calculate_lot_size(account.balance, 0.005, stop_loss_pips, pip_value, info.volume_step)
            result = await exec_svc.place_market_order(symbol, "buy", lot, stop_loss_price, latest.close + (info.point * 100), comment="example")
            logger.info(f"Place order result: {result}")
        else:
            logger.info("No entry signal - holding")

    finally:
        await connector.disconnect()

# ------------------------------- Module Export ---------------------------------

__all__ = [
    "MT5Connector",
    "MT5MarketDataRepository",
    "MT5TradeExecutionService",
    "calculate_lot_size",
    "SymbolInfo",
    "MarketCandle",
    "AccountState",
    "OrderResult",
]

# If run as script, demonstrate module usage (will warn when MetaTrader5 not installed)
if __name__ == "__main__":
    import asyncio
    async def main():
        try:
            await example_decision_cycle("EURUSD")
        except Exception as ex:
            logger.exception("Example run failed: %s", ex)
    asyncio.run(main())
